#!/usr/bin/env node
// Generated by CoffeeScript 1.4.0
var domain, fs, http, load, mime, path, soma, url, zlib,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

domain = require('domain');

http = require('http');

fs = require('fs');

path = require('path');

url = require('url');

zlib = require('zlib');

mime = require('../lib/node/lib/mime');

soma = require('soma');

load = function(source, exec, serve) {
  var abs, m, name, names, pathname, pathnames, stats, watcher, _i, _len;
  stats = fs.statSync(source);
  if (stats.isDirectory()) {
    pathnames = [];
    names = fs.readdirSync(source);
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      if (name[0] === '.') {
        continue;
      }
      pathnames = pathnames.concat(load("" + source + "/" + name, exec, serve));
    }
    return pathnames;
  } else {
    abs = "" + (process.cwd()) + "/" + source;
    pathname = "/" + source;
    if (__indexOf.call(soma.files, pathname) >= 0) {
      return;
    }
    watcher = fs.watch(source, function() {
      var encoding, _ref;
      if (!path.existsSync(source)) {
        console.log('Module went missing: ', source);
        watcher.close();
        return;
      }
      try {
        if (serve) {
          if ((_ref = mime.lookup(source).slice(0, 4)) === 'text') {
            encoding = 'utf8';
          }
          return soma.files[pathname] = fs.readFileSync(source, encoding);
        }
      } catch (e) {
        console.log('Failed to reload module: ', source);
        return console.log(e.stack);
      }
    });
    watcher.emit('change');
    if (exec && source.slice(-3) === '.js') {
      soma._src = pathname;
      m = require(abs);
      soma._src = null;
    }
    return [pathname];
  }
};

soma.init = function() {
  var key, scripts, serverDomain, source, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;
  soma.files = {};
  _ref = JSON.parse(fs.readFileSync('package.json')).soma;
  for (key in _ref) {
    value = _ref[key];
    soma.config[key] = value;
  }
  _ref1 = soma.config.shared;
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    source = _ref1[_i];
    load(path.normalize(source), true, true);
  }
  _ref2 = soma.config.server;
  for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
    source = _ref2[_j];
    load(path.normalize(source), true, false);
  }
  _ref3 = soma.config.client;
  for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
    source = _ref3[_k];
    load(path.normalize(source), false, true);
  }
  scripts = [];
  _ref4 = soma.config.init;
  for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
    source = _ref4[_l];
    scripts = scripts.concat(load(path.normalize(source), false, true));
  }
  serverDomain = domain.create();
  return serverDomain.run(function() {
    var port, server;
    server = http.createServer(function(request, response) {
      var requestDomain;
      requestDomain = domain.create();
      requestDomain.add(request);
      requestDomain.add(response);
      requestDomain.on('error', function(err) {
        console.error('Error', request.url, (err != null ? err.stack : void 0) || err);
        try {
          response.statusCode = 500;
          response.end('Error occurred, sorry.');
          return response.on('close', function() {
            return requestDomain.dispose();
          });
        } catch (err) {
          console.error('Error sending 500', request.url, err);
          return requestDomain.dispose();
        }
      });
      return requestDomain.run(function() {
        var acceptEncoding, content, contentEncoding, context, pathname, sendContent;
        pathname = url.parse(request.url).pathname;
        if (pathname in soma.files) {
          content = soma.files[pathname];
          sendContent = function(err, content) {
            if (err) {
              throw err;
            }
            response.setHeader('Content-Type', mime.lookup(pathname));
            response.setHeader('Content-Length', content.length);
            response.setHeader('Content-Encoding', contentEncoding);
            return response.end(content);
          };
          acceptEncoding = request.headers['accept-encoding'] || '';
          if (acceptEncoding.match(/\bdeflate\b/)) {
            contentEncoding = 'deflate';
            return zlib.deflate(content, sendContent);
          } else if (acceptEncoding.match(/\bgzip\b/)) {
            contentEncoding = 'gzip';
            return zlib.gzip(content, sendContent);
          } else {
            if (!(content instanceof Buffer)) {
              content = new Buffer(content);
            }
            contentEncoding = 'identity';
            return sendContent(null, content);
          }
        } else {
          context = new soma.ClientContext(request, response, scripts);
          return context.begin();
        }
      });
    });
    port = process.env.PORT || soma.config.port || 8000;
    server.listen(port);
    return console.log("Soma listening on port " + port + "...");
  });
};

soma.init();
