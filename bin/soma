#!/usr/bin/env node
// Generated by CoffeeScript 1.3.3
var fs, http, load, mime, path, soma,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

http = require('http');

fs = require('fs');

path = require('path');

mime = require('../lib/node/lib/mime');

soma = require('soma');

load = function(source, exec, serve) {
  var abs, m, name, names, stats, url, urls, watcher, _i, _len;
  stats = fs.statSync(source);
  if (stats.isDirectory()) {
    urls = [];
    names = fs.readdirSync(source);
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      if (name[0] === '.') {
        continue;
      }
      urls = urls.concat(load("" + source + "/" + name, exec, serve));
    }
    return urls;
  } else {
    abs = "" + (process.cwd()) + "/" + source;
    url = "/" + source;
    if (__indexOf.call(soma.files, url) >= 0) {
      return;
    }
    watcher = fs.watch(source, function() {
      var encoding, _ref;
      if (!path.existsSync(source)) {
        console.log('Module went missing: ', source);
        watcher.close();
        return;
      }
      try {
        if (serve) {
          if ((_ref = mime.lookup(source).slice(0, 4)) === 'text') {
            encoding = 'utf8';
          }
          return soma.files[url] = fs.readFileSync(source, encoding);
        }
      } catch (e) {
        console.log('Failed to reload module: ', source);
        return console.log(e.stack);
      }
    });
    watcher.emit('change');
    if (exec && source.slice(-3) === '.js') {
      soma._src = url;
      m = require(abs);
      soma._src = null;
    }
    return [url];
  }
};

soma.init = function() {
  var packageJSON, port, scripts, server, source, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
  soma.files = {};
  packageJSON = JSON.parse(fs.readFileSync('package.json'));
  _ref = packageJSON.soma.shared;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    source = _ref[_i];
    load(path.normalize(source), true, true);
  }
  _ref1 = packageJSON.soma.server;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    source = _ref1[_j];
    load(path.normalize(source), true, false);
  }
  _ref2 = packageJSON.soma.client;
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    source = _ref2[_k];
    load(path.normalize(source), false, true);
  }
  scripts = [];
  _ref3 = packageJSON.soma.init;
  for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
    source = _ref3[_l];
    scripts = scripts.concat(load(path.normalize(source), false, true));
  }
  server = http.createServer(function(request, response) {
    var content, contentLength, contentType, context;
    if (request.url in soma.files) {
      contentType = mime.lookup(request.url);
      content = soma.files[request.url];
      if (content instanceof Buffer) {
        contentLength = content.length;
      } else {
        contentLength = Buffer.byteLength(content);
      }
      response.setHeader('Content-Type', contentType);
      response.setHeader('Content-Length', contentLength);
      return response.end(content);
    } else {
      context = new soma.ClientContext(request, response, scripts);
      return context.begin();
    }
  });
  port = process.env.PORT || packageJSON.soma.port || 8000;
  server.listen(port);
  return console.log("Soma listening on port " + port + "...");
};

soma.init();
